#include "RawNegaScout.h"

namespace soccer { namespace ai { namespace ab {

RawNegaScout::RawNegaScout(Heuristic heuristic, int depth):
	AlphaBeta(std::move(heuristic), depth)
{
}

double RawNegaScout::alphaBeta_(GameState& state, int color, int depth,
								double alpha, double beta, Direction& move
#ifdef DEBUG
						 		, std::list<Direction>& sequence
#endif
								)
{
	if(state.isGameOver() || !depth)
		return heuristic_(state, 0) * color;
	
	move = DIR_END;
	
#ifdef DEBUG
	std::list<Direction> bestSequence;
#endif

	Direction dirs[DIR_END];
	orderMoves_(dirs, state, depth, alpha, beta);

	bool first = true;
	for(int i = 0; i < DIR_END; ++i)
	{
		Direction direction = dirs[i];

		if(!state.canMove(direction))
			continue;

#ifdef DEBUG
		std::list<Direction> seq;
		seq.push_back(direction);
#endif

		const double EPS = 0.000001;

		state.move(direction);
		Direction dir = DIR_END;
		int flip = state.canRebound() ? 1 : -1;
		double value = 0, na = 0, nb = 0;
		if(!first)
		{
			bool b = state.canRebound();
			if(state.canRebound())
				//na = beta - EPS, nb = beta;
				na = alpha, nb = alpha + EPS;
			else{
				na = -alpha - EPS, nb = -alpha;
			value = flip * alphaBeta_(state, flip * color, depth - 1, na, nb, dir
#ifdef DEBUG
									  , seq
#endif
									 );}
			if(alpha < value && value < beta || b)
			{
#ifdef DEBUG
				seq.clear();
				seq.push_back(direction);
#endif
			
				if(state.canRebound())
					na = value, nb = beta;
				else
					na = -beta, nb = -value;
				value = flip * alphaBeta_(state, flip * color, depth - 1, na, nb, dir
#ifdef DEBUG
										  , seq
#endif
										 );
			}
		}
		else
		{
			if(state.canRebound())
				na = alpha, nb = beta;
			else
				na = -beta, nb = -alpha;
			value = flip * alphaBeta_(state, flip * color, depth - 1, na, nb, dir
#ifdef DEBUG
									  , seq
#endif
									 );
									 
			first = false;
		}
		state.undo(direction);

		if(value > alpha || move == DIR_END)
		{
			alpha = value;
			move = direction;
#ifdef DEBUG
			bestSequence = std::move(seq);
#endif

			if(alpha >= beta)
				break;
		}
	}

#ifdef DEBUG
		sequence.splice(sequence.end(), bestSequence);
#endif

	return alpha;
}

} } }